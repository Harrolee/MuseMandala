using System.Collections;
using System.Collections.Generic;
using UnityEngine;

//next we need to more gracefully place the points. Ideally, the points appear as though they are being drawn.
//The "end" point is created as a gameobject and then the entire curve-generator apparatus runs on that single point.
    //in this design, we do not have control over the speed of the points generated by the curve-generator apparatus.
    //There is a "point cleaner-upper" in linerenderer class. I could use it after passing in a list of generated points, one after the other on a slight delay.
    //hmmm...
        //how can i implement the function of this class in a way that aligns with my needs?
//tomorrow, check out how other people lerp line renderers smoothly.

namespace EasyCurvedLine
{

    public class PointGenerator : MonoBehaviour
    {
        public int NewPoints = 10;
        public GameObject _CurvePoint;
        CurvedLineRenderer curvedLine;
        Vector3 childVec;
        Vector3 newVec;

        private void Start()
        {
            curvedLine = GetComponent<CurvedLineRenderer>();
        }

        private void Update()
        {
            if(Input.GetKeyDown(KeyCode.Space))
                StartCoroutine(AddPoints(NewPoints));
        }

        public IEnumerator AddPoints(int numToAdd)
        {
            for (int i = 0; i < NewPoints; i++)
            {
                //get vec3 of latest child
                childVec = transform.GetChild(transform.childCount-1).position;
                //transform that vec3 and set it to newVec
                if(i%2==0)
                    newVec = childVec + new Vector3(0, .2f);
                else
                    newVec = childVec + new Vector3(.2f, 0);
                //instantiate a new gameObject at newVec as a new child
                Instantiate(_CurvePoint, newVec, Quaternion.identity, transform);
                //use curvedLine to generate curves around the new point

                if (curvedLine != null)
                {
                    curvedLine.Update();
                }
                yield return new WaitForSeconds(.1f);
            }
        } 
        //get vector3 of child[length-1]
        // increment vector3.x by 1
        //next point = new vector3
        //instantiate new prefab at next point and call LineSmoother.Update
        



        /* may or may not need the following:
         
        //lerped point list = vector3.lerp(vector3 of child[length-1], next point,  time.deltatime)
        //make a child with curvedLinePoint with the values in this list
        
         */    
    }
}
