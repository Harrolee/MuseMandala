using System.Collections;
using System.Collections.Generic;
using UnityEngine;

//next we need to more gracefully place the points. Ideally, the points appear as though they are being drawn.
//The "end" point is created as a gameobject and then the entire curve-generator apparatus runs on that single point.
    //in this design, we do not have control over the speed of the points generated by the curve-generator apparatus.
    //There is a "point cleaner-upper" in linerenderer class. I could use it after passing in a list of generated points, one after the other on a slight delay.
    //hmmm...
        //how can i implement the function of this class in a way that aligns with my needs?
//tomorrow, check out how other people lerp line renderers smoothly.

namespace EasyCurvedLine
{

    public class PointGenerator : MonoBehaviour
    {
        
        /* 
        public GameObject sph;
        float distCovered;
        float fracJourney;
        float startTime;
        float journeyLength;
        Vector3 endestPoint;
*/
/* 
        public int Speed = 1;
        public int NewPoints = 10;
        public GameObject _CurvePoint;
        CurvedLineRenderer curvedLine;
        Vector3 childVec;
        Vector3 newVec;
        List<Vector3> DeclaredPoints = new List<Vector3>();
        List<Vector3> PointList = new List<Vector3>();

        private void Start()
        {
            curvedLine = GetComponent<CurvedLineRenderer>();
            startTime = Time.time;
        }

        private void Update()
        {
            if(Input.GetKeyDown(KeyCode.Space))
                LerpThroughList();
            else if(Input.GetKeyDown(KeyCode.A)){
              endestPoint=sph.transform.position + new Vector3(20,20);
              journeyLength = Vector3.Distance(sph.transform.position, endestPoint);
              TestLerp();
            }
        }
*/

/* 
        void TestLerp()
        {
        while(fracJourney<journeyLength)
        {
        distCovered = (Time.time - startTime) * Speed;
        // Fraction of journey completed = current distance divided by total distance.
        fracJourney = distCovered / journeyLength;
        sph.transform.position = Vector3.Lerp(sph.transform.position, endestPoint, fracJourney);
        }
        }
*/
        //You have a list of points
        //traverse list of points.
            //for the first point, find the location of the current last child.
            //create children between the currlast child and the first point.
        //get the next list of points || be done
/* 
        Vector3 startPoint;
        Vector3 endPoint;
        Vector3 nextPoint;
        void LerpThroughList()
        {
            DeclaredPoints = DeclarePoints(NewPoints);
            for(int i=0; i<DeclaredPoints.Count; i++)
            {
                if (i==0)
                {
                    startPoint = transform.GetChild(transform.childCount-1).position;
                    endPoint = DeclaredPoints[i];
                }
                else
                {
                    startPoint = DeclaredPoints[i-1];
                    endPoint = DeclaredPoints[i];
                }
                //lerp make new points
                nextPoint=Vector3.Lerp(startPoint, endPoint, Time.deltaTime * Speed * .2f);
                Instantiate( _CurvePoint, nextPoint, Quaternion.identity, transform);
            }
        }
*/
        /* 
        List<Vector3> DeclarePoints(int numToAdd)
        {
            print(transform.childCount);
            for(int i = 0; i< numToAdd; i++)
            {
                //get vec3 of latest child
                childVec = transform.GetChild(transform.childCount-1).position;
                //transform that vec3 and set it to newVec
                if(i%2==0)
                    newVec = childVec + new Vector3(0, .2f);
                else
                    newVec = childVec + new Vector3(.2f, 0);

                PointList.Add(newVec);
            }
            return PointList;
        } 
        */
    }
}
