using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.EventSystems;

public class LineSource : MonoBehaviour
{

    public static int sectionCount = 1;
    public float speed = 1;//move to SO
    public int numPointsPerLine = 15;
    LineRenderer sourceLine;
    public GameObject _ChildLineRenderer;
    public int NumLinesPerSection = 4;

    //the reflections of sourceLine in each section.
    public Vector3[,] sectionReflections;
    //public List<LineRenderer> allLines = new List<LineRenderer>();//why tf is this a list of LineRenderers?--After 6/26
    //public List<Vector3[]> allLines = new List<Vector3[]>();




    void Awake()
    {       //center by force. For later, consider whether there is anything preventing this from working when not at origin.
        gameObject.transform.position = Vector3.zero;
        //put on object with a lineRenderer

        //prepare lineRend to carry the points
        sourceLine = GetComponent<LineRenderer>();
        sourceLine.SetPosition(0, transform.position);
        sourceLine.positionCount = numPointsPerLine;
        sourceLine.numCapVertices = 3;
        sourceLine.numCornerVertices = 3;

        //when the SO is implemented, reference data from SO
        /*
        reflections = lineParams.Reflections;
        sections = lineParams.Sections;
        */

        if (_ChildLineRenderer == null)
            _ChildLineRenderer = gameObject;
    }

    void Start()
    {
        if (sectionCount != 0)
        {
            //create children, one for each Reflection.
            MakeChildLR(sourceLine, NumLinesPerSection);
            sectionCount--;
        }
        else
            print("Made Enough Children");
    }


    void Update()
    {
        if (Input.GetKeyDown(KeyCode.A))
            CallRender();
        if (Input.GetKeyDown(KeyCode.Space))
        {
            GenerateSection();
            //the following for if children inherit this script
            //if (transform.GetSiblingIndex() == 2 && transform.childCount == 4)
            //{
            //    WholeEnchilada();
            //}
        }
    }


    void GenerateSection()
    {
        //for 6/26 demo, all sections will have the same number of points and there will be 7 sections.
        //this gives us a source line for each section.

        sectionReflections = ReflectLine(MakePoints());
    }
    

    void CallRender()
    {
        Vector3[] arrayToPass = new Vector3[numPointsPerLine];
        //extract one line for each row of the multidimensional array
        for (int ii = 0; ii < transform.childCount; ii++)
        {
            for (int jj = 0; jj < numPointsPerLine; jj++)
            {
                arrayToPass[jj] = sectionReflections[ii, jj];
                arrayToPass[jj] = sectionReflections[ii, jj];
            }
            //pass a different line to each child.
            transform.GetChild(ii).GetComponent<ChildLineRunner>().StartLineRender(arrayToPass);
        }
    }


    Vector3[] MakePoints()
    {
        Vector3[] pointsArr = new Vector3[numPointsPerLine];

        //I think i=1 because index 0 has to be vector3.zero
        for (int i = 1; i < numPointsPerLine; i++)
        {
            if (i % 7 == 0)
                pointsArr[i] = (pointsArr[i - 1] + new Vector3(2, 1, -1));
            else if (i % 5 == 0)
                pointsArr[i] = (pointsArr[i - 1] + new Vector3(2, 2, -.5f));
            else if (i % 3 == 0)
                pointsArr[i] = (pointsArr[i - 1] + new Vector3(1, 1, -.5f));
            else if (i % 2 == 0)
                pointsArr[i] = (pointsArr[i - 1] + new Vector3(1, 0, -.2f));
            else
                pointsArr[i] = (pointsArr[i - 1] + new Vector3(1, 0));
            //after 6/26 demo, use a prime number function to scale this behaviour to the declared number of points
            //add a coeff to each dimension to scale their tilt
        }
        return pointsArr;
    }


    //returns a list of reflected lines
    //reflect ListOfPoints reflectionCount times
    Vector3[,] ReflectLine(Vector3[] line)
    {
        //multi-dimensional array to contain the reflected vector3 arrays.
        Vector3[,] fullSection = new Vector3[NumLinesPerSection, numPointsPerLine];

        int theta;
        Vector3 dummy3;
        theta = 360 / NumLinesPerSection;


        for (int ii = 0; ii < NumLinesPerSection; ii++)
        {
            //For each row, calculate a new value for theta. This has the effect of reflecting evenly accross the circle.
            dummy3 = new Vector3(Mathf.Cos(theta * ii), Mathf.Sin(theta * ii), 0);
            for (int jj = 0; jj < numPointsPerLine; jj++)
            {
                //reflect the original point across a line generated by the number of reflections desired.
                fullSection[ii, jj] = Vector3.Reflect(line[jj], dummy3);
            }
        }
        return fullSection;
    }


    void MakeChildLR(LineRenderer parentLR, int numOfChildren)
    {
        for (int i = 0; i < numOfChildren; i++)
        {
            Instantiate(_ChildLineRenderer, parentLR.transform);
        }

    }
}